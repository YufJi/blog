(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{403:function(t,e,a){"use strict";a.r(e);var n=a(49),v=Object(n.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"自定义组件web-component化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#自定义组件web-component化"}},[t._v("#")]),t._v(" 自定义组件web-component化")]),t._v(" "),a("h2",{attrs:{id:"目前主要问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#目前主要问题"}},[t._v("#")]),t._v(" 目前主要问题")]),t._v(" "),a("p",[t._v("生命周期执行顺序与微信不一致")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("微信")]),t._v(" "),a("th",[t._v("Tiny")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("component created")]),t._v(" "),a("td",[t._v("page load")])]),t._v(" "),a("tr",[a("td",[t._v("component attached")]),t._v(" "),a("td",[t._v("component created")])]),t._v(" "),a("tr",[a("td",[t._v("page load")]),t._v(" "),a("td",[t._v("component attached")])]),t._v(" "),a("tr",[a("td",[t._v("page show")]),t._v(" "),a("td",[t._v("component ready")])]),t._v(" "),a("tr",[a("td",[t._v("component ready")]),t._v(" "),a("td",[t._v("page show")])]),t._v(" "),a("tr",[a("td",[t._v("page ready")]),t._v(" "),a("td",[t._v("page ready")])])])]),t._v(" "),a("p",[t._v("根本原因是React生命周期与web-component生命周期的不一致")]),t._v(" "),a("h2",{attrs:{id:"解决方案-猜想阶段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解决方案-猜想阶段"}},[t._v("#")]),t._v(" 解决方案（猜想阶段）")]),t._v(" "),a("ul",[a("li",[t._v("渲染全部web-component化")]),t._v(" "),a("li",[t._v("使用lit、polymer等库")])]),t._v(" "),a("h2",{attrs:{id:"与此同时需要解决的问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#与此同时需要解决的问题"}},[t._v("#")]),t._v(" 与此同时需要解决的问题")]),t._v(" "),a("blockquote",[a("p",[t._v("比较简单")])]),t._v(" "),a("ul",[a("li",[t._v("事件系统问题")]),t._v(" "),a("li",[t._v("style、animation属性处理")])]),t._v(" "),a("h2",{attrs:{id:"编译层处理事项-猜想"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#编译层处理事项-猜想"}},[t._v("#")]),t._v(" 编译层处理事项（猜想）")]),t._v(" "),a("ul",[a("li",[t._v("模板引用")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("import { html } from 'lit';\n\nimport b from './b.wxml'\nimport c from './c.wxml'\n\n// 自己定义的template\nexport const _ownTemplates = {}\n// 自己定义的template + 外部import的template\nconst _templates = { ..._ownTemplates, ...c._ownTemplates }\n\nconst _html = html`\n  <view>1212</view>\n  ${b}\n  ${_templates.a}\n  ${_templates.c}\n`\n\nexport default _html;\n")])])]),a("ul",[a("li",[t._v("template定义")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('const templateName = \'\'\n\ncustomElements.define(templateName, class extends PolymerElement {\n  static get is() { return templateName }\n  static get properties() {\n    return {\n      data: { type: Object }\n    }\n  }\n\n  static get template() {\n    return html`\n      <view bindtap="eventBinder" event-name="xx" >{{data.abc}}</view>\n    `\n  }\n\n  eventBinder(e) {\n\n  }\n\n});\n\n')])])]),a("h2",{attrs:{id:"最终方案记录"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#最终方案记录"}},[t._v("#")]),t._v(" 最终方案记录")]),t._v(" "),a("p",[t._v("1、 主要问题")]),t._v(" "),a("ul",[a("li",[t._v("生命周期与微信不一致")]),t._v(" "),a("li",[t._v("两套渲染机制（page和自定义组件走的mini版react， 内置组件走的web-component）")])]),t._v(" "),a("p",[t._v("2、 预期")]),t._v(" "),a("ul",[a("li",[t._v("渲染机制保持一致")]),t._v(" "),a("li",[t._v("生命周期一致")])]),t._v(" "),a("p",[t._v("3、 解决过程")]),t._v(" "),a("p",[t._v("一开始的想法时使用polymer或者lit这样的web-component组件库去实现，模板解析也交它们， 但是捣鼓了一天下来发现模板解析很不动态， 数据绑定也很死板，幸好生命周期是完全对上了。至此得出结论，web-compoent化是正确的，但是模板解析还是得走vdom实现，不然解析太麻烦了，因此上面提到的编译环节的处理就可以不用修改。")]),t._v(" "),a("p",[t._v("就在准备在polymer中使用react时，忽然想起omi这个库的web-component + jsx vdom能力。")]),t._v(" "),a("p",[t._v("魔改一下，成了，当然修改点肯定还是比较多的。")])])}),[],!1,null,null,null);e.default=v.exports}}]);